{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"building/","text":"Building an object Problem How does a user specify something to be built? We would like to simply specify the resulting object and the ComputePod system will then determine what needs to be built. There are a number of phases in building an object: Dependency Analysis (building an internal dependency graph (which because of ConTeXt is cyclic )). Execution of the build we plan to use a tup style build execution. (see: Build System Rules and Algorithms (PDF) , see also sake )) Solution To specify something to be built, the user will specify a high-level (YAML) project description file as well as a \"target\" described in the description file. These project description files arelocated in the top-level of the project directory hierarchy. A user specifies three things: A project (a directory inside the user's ComputePod assigned area) A project description file (inside the top-level directory of the project). A project target (specified inside the project description). Questions How does the system know which workers can add to the dependency analysis: if there are multiple (possible) ways to build the same object? if there are no \"bridges\" between types of artifacts (such as the ConTeXt documents which \"create\" source code)? A : All of this high-level detail should be specified in the project description file.","title":"Building an object"},{"location":"building/#building-an-object","text":"","title":"Building an object"},{"location":"building/#problem","text":"How does a user specify something to be built? We would like to simply specify the resulting object and the ComputePod system will then determine what needs to be built. There are a number of phases in building an object: Dependency Analysis (building an internal dependency graph (which because of ConTeXt is cyclic )). Execution of the build we plan to use a tup style build execution. (see: Build System Rules and Algorithms (PDF) , see also sake ))","title":"Problem"},{"location":"building/#solution","text":"To specify something to be built, the user will specify a high-level (YAML) project description file as well as a \"target\" described in the description file. These project description files arelocated in the top-level of the project directory hierarchy. A user specifies three things: A project (a directory inside the user's ComputePod assigned area) A project description file (inside the top-level directory of the project). A project target (specified inside the project description).","title":"Solution"},{"location":"building/#questions","text":"How does the system know which workers can add to the dependency analysis: if there are multiple (possible) ways to build the same object? if there are no \"bridges\" between types of artifacts (such as the ConTeXt documents which \"create\" source code)? A : All of this high-level detail should be specified in the project description file.","title":"Questions"},{"location":"dependencyAnalysis/","text":"Dependency analysis Problem While each ComputePod worker will have default knowledge of how to build objects in its area of specialty, this will often not be enough to build a large complex project which spans the domains of multiple workers. How do we suplement the \"default\" dependency knowledge? Examples For example, ConTeXt document collections have a definite suggested structure using the ConText Project structures . Unfortunately, this \"default\" directory structure (and their associated ConTeXt declarations) does not include information about what diSimplex Code objects these ConTeXt documents might produce. The names of these code objects might have no relationship with, for example, the names of the containing ConTeXt documents. This means that, by default, the ComputePod workers will have no obvious way to infer that the request to build a given Code object, requires the typesetting of the associated ConTeXt documents. Requirements We need a simple text format in which to specify these high-level dependencies. This format also needs to be readable by multiple programming/scripting languages. This text format needs to support the specification of \"simple\" rules for associating artifacts with dependencies. Generally generic and/or details of dynamically generated dependencies should be located in the worker's associated ComputeChef plugins (and not the \"high-level\" project descriptions). Solution We will use a YAML format based upon the Sake format to describe the dependencies in a project . This description should be sufficient to start the dependecy analysis phase. We expect the worker's ComputePodChefs to be able to fill in the fine dependency details as well as the rules required to build each (micro) step. The project description file will be located in the top-level of the project file directories. Project descriptions will not contain Python or Lua (or any Turing complete) code. They may contain wildcards describing other project files (which could be additional (sub)project description files). Potential formats Our own format This would require a parser etc... ;-( YAML This is a nice format which is easily human readable, and which allows comments. There are Python, GoLang, and ANSI-C parsers, but unfortunately there is no pure Lua parser (see lua-tinyyaml ). Generation of these high-level project description files should be fairly easy in most languages. The use of (standard) \"wildcard\" characters (' ', '%', etc) in YAML strings tends to confuse YAML parsers. Which means that users must* put \"rules\" inside quoted strings. JSON This format is machine readable but can be rather wordy, and does not allow comments. There are parsers in Python, GoLang, ANSI-C and (pure) Lua (at least in ConTeXt's version). Lua Pure Lua source code could be used as a text format. It can be embedded in both ANSI-C, Python and GoLang. Unfortunately it is rather over powered (being Turing Complete). Python Pure Python source code could be used as a text format. It could only be used in ANSI-C(?) and Python. Again, it is rather over powered. Questions What sorts of dependency rules are used in build systems? see: Sake for a YAML example see: tup for an example of a simple non-standard format. see: Rake for an example of a Ruby DSL (which is ultimately Turing complete). How should we include more complex dependency rules? Sould/could we use Python or Lua code? (Is this not too overpowered and a security risk?) A : We will NOT include any Turing complete \"code\". Any such code must be contained in the worker's Chef plugins (as python code), which is \"installed\" at pod build time (rather than pod runtime).","title":"Dependency analysis"},{"location":"dependencyAnalysis/#dependency-analysis","text":"","title":"Dependency analysis"},{"location":"dependencyAnalysis/#problem","text":"While each ComputePod worker will have default knowledge of how to build objects in its area of specialty, this will often not be enough to build a large complex project which spans the domains of multiple workers. How do we suplement the \"default\" dependency knowledge?","title":"Problem"},{"location":"dependencyAnalysis/#examples","text":"For example, ConTeXt document collections have a definite suggested structure using the ConText Project structures . Unfortunately, this \"default\" directory structure (and their associated ConTeXt declarations) does not include information about what diSimplex Code objects these ConTeXt documents might produce. The names of these code objects might have no relationship with, for example, the names of the containing ConTeXt documents. This means that, by default, the ComputePod workers will have no obvious way to infer that the request to build a given Code object, requires the typesetting of the associated ConTeXt documents.","title":"Examples"},{"location":"dependencyAnalysis/#requirements","text":"We need a simple text format in which to specify these high-level dependencies. This format also needs to be readable by multiple programming/scripting languages. This text format needs to support the specification of \"simple\" rules for associating artifacts with dependencies. Generally generic and/or details of dynamically generated dependencies should be located in the worker's associated ComputeChef plugins (and not the \"high-level\" project descriptions).","title":"Requirements"},{"location":"dependencyAnalysis/#solution","text":"We will use a YAML format based upon the Sake format to describe the dependencies in a project . This description should be sufficient to start the dependecy analysis phase. We expect the worker's ComputePodChefs to be able to fill in the fine dependency details as well as the rules required to build each (micro) step. The project description file will be located in the top-level of the project file directories. Project descriptions will not contain Python or Lua (or any Turing complete) code. They may contain wildcards describing other project files (which could be additional (sub)project description files).","title":"Solution"},{"location":"dependencyAnalysis/#potential-formats","text":"Our own format This would require a parser etc... ;-( YAML This is a nice format which is easily human readable, and which allows comments. There are Python, GoLang, and ANSI-C parsers, but unfortunately there is no pure Lua parser (see lua-tinyyaml ). Generation of these high-level project description files should be fairly easy in most languages. The use of (standard) \"wildcard\" characters (' ', '%', etc) in YAML strings tends to confuse YAML parsers. Which means that users must* put \"rules\" inside quoted strings. JSON This format is machine readable but can be rather wordy, and does not allow comments. There are parsers in Python, GoLang, ANSI-C and (pure) Lua (at least in ConTeXt's version). Lua Pure Lua source code could be used as a text format. It can be embedded in both ANSI-C, Python and GoLang. Unfortunately it is rather over powered (being Turing Complete). Python Pure Python source code could be used as a text format. It could only be used in ANSI-C(?) and Python. Again, it is rather over powered.","title":"Potential formats"},{"location":"dependencyAnalysis/#questions","text":"What sorts of dependency rules are used in build systems? see: Sake for a YAML example see: tup for an example of a simple non-standard format. see: Rake for an example of a Ruby DSL (which is ultimately Turing complete). How should we include more complex dependency rules? Sould/could we use Python or Lua code? (Is this not too overpowered and a security risk?) A : We will NOT include any Turing complete \"code\". Any such code must be contained in the worker's Chef plugins (as python code), which is \"installed\" at pod build time (rather than pod runtime).","title":"Questions"},{"location":"ui/","text":"User interface (webpages) Goal We need a simple and dynamic user interface with which to control and monitor the ComputePods (ongoing) behaviour. This interface should be run-able inside modern browsers (such as FireFox and Chromium). Nice to have We will need a hierachical view of project files, as well as tasks and associated logfiles. Since the ComputePods will build up an intimate knowledge of the artifacts it builds, down to locations of cross-references, figures, chapters, sections, etc for ConTeXt, as well as varialbe and function definitions for ANSI-C and JoyLoL, it will eventually mmake sense to expose this knowledge by being able to \"jump\" to the textual source underlying each (generalized) reference. This suggests the use of an embedded \"code\" editor (CodeJar), as well as syntax highlighting (Prism). The ability to have multiple panes open on tasks side by side, suggests the use of a split panel JavaScript tool (SplitJS). The ability to visualize the grapical networks of, for example, (potentially cyclic) build dependency networks, or concept cross-reference networks, suggests the use of D3 (and SVG). Word clouds, driven by D3, might make nice entries into the concept cross-reference networks (clouds). UI Our UI itself is based upon \"standard\" JavaScript run in the client's browser. JavaScript W3C DOM Mozilla DOM UI Packages Our objective in chosing the UI packages is to keep things as \"simple\" and \"independently\" \"mixable\" as possible. At this point it is hard to see how we might want to mix and match tools to create a useful user experience, but certainly keeping things as modular as possible will allow for future inspiration. Mithril Material Design Lite D3 D3-mitch-tree SplitJS CodeJar Prism Note we will probabaly eventually need to create our own langauge for JoyLoL. So we want to use Prism now to allow this in the future. We will use the Webpack and Uglify development tools (below) to programatically produce our own minified prism files. UI development tools UglifyJS UglifyCSS Webpack","title":"User interface (webpages)"},{"location":"ui/#user-interface-webpages","text":"","title":"User interface (webpages)"},{"location":"ui/#goal","text":"We need a simple and dynamic user interface with which to control and monitor the ComputePods (ongoing) behaviour. This interface should be run-able inside modern browsers (such as FireFox and Chromium).","title":"Goal"},{"location":"ui/#nice-to-have","text":"We will need a hierachical view of project files, as well as tasks and associated logfiles. Since the ComputePods will build up an intimate knowledge of the artifacts it builds, down to locations of cross-references, figures, chapters, sections, etc for ConTeXt, as well as varialbe and function definitions for ANSI-C and JoyLoL, it will eventually mmake sense to expose this knowledge by being able to \"jump\" to the textual source underlying each (generalized) reference. This suggests the use of an embedded \"code\" editor (CodeJar), as well as syntax highlighting (Prism). The ability to have multiple panes open on tasks side by side, suggests the use of a split panel JavaScript tool (SplitJS). The ability to visualize the grapical networks of, for example, (potentially cyclic) build dependency networks, or concept cross-reference networks, suggests the use of D3 (and SVG). Word clouds, driven by D3, might make nice entries into the concept cross-reference networks (clouds).","title":"Nice to have"},{"location":"ui/#ui","text":"Our UI itself is based upon \"standard\" JavaScript run in the client's browser. JavaScript W3C DOM Mozilla DOM","title":"UI"},{"location":"ui/#ui-packages","text":"Our objective in chosing the UI packages is to keep things as \"simple\" and \"independently\" \"mixable\" as possible. At this point it is hard to see how we might want to mix and match tools to create a useful user experience, but certainly keeping things as modular as possible will allow for future inspiration. Mithril Material Design Lite D3 D3-mitch-tree SplitJS CodeJar Prism Note we will probabaly eventually need to create our own langauge for JoyLoL. So we want to use Prism now to allow this in the future. We will use the Webpack and Uglify development tools (below) to programatically produce our own minified prism files.","title":"UI Packages"},{"location":"ui/#ui-development-tools","text":"UglifyJS UglifyCSS Webpack","title":"UI development tools"},{"location":"resources/clientSide/","text":"Client side JavaScript webapp Framework Mithril Graphics D3 Hierarchy D3-mitch-tree (checkbox) TreeJS Embedded JS code editor? Ace CodeMirror CodeJar with Prism Split panels SplitJS https://stackoverflow.com/questions/12194469/best-way-to-do-a-split-pane-in-html https://www.syncfusion.com/javascript-ui-controls/js-splitter https://webdesign.tutsplus.com/tutorials/how-to-create-a-split-screen-slider-with-javascript--cms-28844 https://w-shadow.com/blog/2008/10/23/javascript-splitters-and-resizable-panels/ https://www.w3schools.com/howto/howto_css_split_screen.asp UI frameworks Skeleton (CSS only) Material Design Lite BEM Bulma (CSS only) Primer Materialize Milligram Tachyons Semantic-UI Bootstrap (requires jQuery) https://hackr.io/blog/best-css-frameworks https://athemes.com/collections/best-css-frameworks/ https://www.lambdatest.com/blog/best-css-frameworks-2021/ https://dev.to/theme_selection/best-css-frameworks-in-2020-1jjh Server side support for JavaScript (and friends) JavaScript CoffeeScript TypeScript A strictly type-able superset of JavaScript. Babel ECMAScript 2015+ which transpiles to JavaScript with polyfill. Elm A functional language which transpiles to JavaScript. CSS Sassy CSS A CSS processor which is written in Ruby. Less A CSS processor which is written in JavaScript (similar syntax to Sassy CSS). An introduction to CSS preporcessors Minifier UglifyJS (JavaScript - based on JavaScript) UglifyCSS (CSS - based on JavaScript) YUI Comprssor (JavaScript and CSS - but Java based)","title":"Client side JavaScript webapp"},{"location":"resources/clientSide/#client-side-javascript-webapp","text":"","title":"Client side JavaScript webapp"},{"location":"resources/clientSide/#framework","text":"Mithril","title":"Framework"},{"location":"resources/clientSide/#graphics","text":"D3","title":"Graphics"},{"location":"resources/clientSide/#hierarchy","text":"D3-mitch-tree (checkbox) TreeJS","title":"Hierarchy"},{"location":"resources/clientSide/#embedded-js-code-editor","text":"Ace CodeMirror CodeJar with Prism","title":"Embedded JS code editor?"},{"location":"resources/clientSide/#split-panels","text":"SplitJS https://stackoverflow.com/questions/12194469/best-way-to-do-a-split-pane-in-html https://www.syncfusion.com/javascript-ui-controls/js-splitter https://webdesign.tutsplus.com/tutorials/how-to-create-a-split-screen-slider-with-javascript--cms-28844 https://w-shadow.com/blog/2008/10/23/javascript-splitters-and-resizable-panels/ https://www.w3schools.com/howto/howto_css_split_screen.asp","title":"Split panels"},{"location":"resources/clientSide/#ui-frameworks","text":"Skeleton (CSS only) Material Design Lite BEM Bulma (CSS only) Primer Materialize Milligram Tachyons Semantic-UI Bootstrap (requires jQuery) https://hackr.io/blog/best-css-frameworks https://athemes.com/collections/best-css-frameworks/ https://www.lambdatest.com/blog/best-css-frameworks-2021/ https://dev.to/theme_selection/best-css-frameworks-in-2020-1jjh","title":"UI frameworks"},{"location":"resources/clientSide/#server-side-support-for-javascript-and-friends","text":"JavaScript CoffeeScript TypeScript A strictly type-able superset of JavaScript. Babel ECMAScript 2015+ which transpiles to JavaScript with polyfill. Elm A functional language which transpiles to JavaScript. CSS Sassy CSS A CSS processor which is written in Ruby. Less A CSS processor which is written in JavaScript (similar syntax to Sassy CSS). An introduction to CSS preporcessors Minifier UglifyJS (JavaScript - based on JavaScript) UglifyCSS (CSS - based on JavaScript) YUI Comprssor (JavaScript and CSS - but Java based)","title":"Server side support for JavaScript (and friends)"}]}